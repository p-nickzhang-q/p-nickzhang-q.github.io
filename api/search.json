[{"id":"4e5438c9e012a77cb97e209dfb4eefbc","title":"Spring Boot 和 Android 客户端 SSE 实现说明","content":"Spring Boot 和 Android 客户端 SSE 实现说明本项目实现了一个基于 Server-Sent Events (SSE) 的消息推送系统，后端使用 Spring Boot，前端使用 Android 客户端。以下是系统的整体结构和各个部分的详细说明。\n1. Spring Boot 后端实现后端通过 SseEmitter 来实现 SSE 功能。主要功能是为每个客户端维护一个 SseEmitter 实例，通过 SseEmitter 进行消息推送。\n核心代码说明1.1 订阅接口12345678910private val clients = ConcurrentHashMap&lt;String, SseEmitter&gt;()fun subscribe(clientId: String): SseEmitter &#123;    val emitter = SseEmitter(60 * 60_000L) // 1小时超时    clients[clientId] = emitter    emitter.onCompletion &#123; &#125;    emitter.onTimeout &#123; clients.remove(clientId) &#125;    emitter.onError &#123; clients.remove(clientId) &#125;    return emitter&#125;\n\n\nclients 是一个 ConcurrentHashMap，用于存储所有在线客户端的 SseEmitter 实例，clientId 作为客户端的标识。\nsubscribe 方法会为每个客户端创建一个新的 SseEmitter 实例，设置超时时间为 1 小时，并且在事件超时或错误时移除该客户端。\n\n1.2 发送消息接口123456789101112131415161718192021222324const val RemoveClient = &quot;RemoveClient&quot;fun sendEvent(clientId: String, message: String): String &#123;    val emitter = clients[clientId]    return if (emitter != null) &#123;        try &#123;            when (message) &#123;                RemoveClient -&gt; &#123;                    clients.remove(clientId)                &#125;                else -&gt; &#123;                    emitter.send(SseEmitter.event().name(&quot;message&quot;).data(message))                &#125;            &#125;            &quot;Message sent&quot;        &#125; catch (e: IOException) &#123;            clients.remove(clientId)            &quot;Failed to send message&quot;        &#125;    &#125; else &#123;        &quot;Client not found&quot;    &#125;&#125;\n\n\nsendEvent 方法用于向指定客户端发送消息。\n根据不同的消息类型，后端会采取相应的操作，比如移除客户端或推送消息。\n\n2. Android 客户端实现Android 客户端通过 RealEventSource 来接收 SSE 事件，并根据消息内容执行对应的操作。\n核心代码说明2.1 客户端连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enum class SSEMessage(val func: suspend () -&gt; Unit) &#123;    Logout(&#123;        mainVM.logout()    &#125;),    RemoveClient(&#123;        VehicleApi.service.sendEvent(mainVM.user.id!!, RemoveClient.name)    &#125;)&#125;fun connect() &#123;    val request: Request = Request.Builder()        .url(&quot;$&#123;baseUrl&#125;api/v1/em/vehicleauth/subscribe/$&#123;mainVM.user.id!!&#125;&quot;)        .header(STORAGE_AUTHORIZATION, SpUtils.token)        .build()    realEventSource = RealEventSource(request, object : EventSourceListener() &#123;        override fun onEvent(            eventSource: EventSource,            id: String?,            type: String?,            data: String,        ) &#123;            super.onEvent(eventSource, id, type, data)            try &#123;                SSEMessage.valueOf(data)            &#125; catch (e: Exception) &#123;                null            &#125;?.apply &#123;                activity.lifecycleScope.launch &#123;                    func()                &#125;            &#125;        &#125;        override fun onClosed(eventSource: EventSource) &#123;            super.onClosed(eventSource)        &#125;        override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) \t\t &#123;            super.onFailure(eventSource, t, response)        &#125;        override fun onOpen(eventSource: EventSource, response: Response) &#123;            super.onOpen(eventSource, response)        &#125;    &#125;)    realEventSource.connect(client)&#125;\n\n\nconnect 方法用于建立与服务器的 SSE 连接。\nRealEventSource 是 OkHttp 的一个扩展类，能够处理 SSE 协议。\n在接收到事件时，客户端会根据事件的 data 字段来解析消息类型（如 Logout、RemoveClient），并执行相应的操作。\n\n2.2 事件处理12345678enum class SSEMessage(val func: suspend () -&gt; Unit) &#123;    Logout(&#123;        mainVM.logout()    &#125;),    RemoveClient(&#123;        VehicleApi.service.sendEvent(mainVM.user.id!!, RemoveClient.name)    &#125;)&#125;\n\n\nSSEMessage 枚举类定义了两种消息类型：\nLogout: 触发用户登出操作。\nRemoveClient: 通知服务器移除客户端。\n\n\n每个消息类型关联一个挂起函数 (func)，该函数会在接收到事件时执行。\n\n3. 使用说明3.1 后端配置在 Spring Boot 后端中，通过 SseEmitter 实现了 SSE 功能。前端只需要调用 subscribe 方法来订阅特定客户端，然后使用 sendEvent 方法发送消息。\n3.2 客户端配置在 Android 客户端中，通过 RealEventSource 类接收来自后端的 SSE 消息，并根据消息类型执行相应的操作（如登出或移除客户端）。客户端连接会在 connect 方法中建立，消息接收后会根据 SSEMessage 枚举类型来触发不同的操作。\n4. 总结本实现通过 SSE 协议实现了实时消息推送，结合了 Spring Boot 后端和 Android 客户端。后端使用 SseEmitter 来处理与多个客户端的连接，而客户端使用 RealEventSource 接收并处理事件。通过此方式，前后端实现了实时通信，确保系统能够及时响应客户端的请求。\n关键点\n后端使用 SseEmitter 实现 SSE 消息推送。\n客户端使用 RealEventSource 接收实时事件并处理。\n消息类型通过枚举 SSEMessage 定义，并结合挂起函数执行不同的操作。\n\n这样就实现了一个高效、实时的消息推送系统，适用于需要实时通知和更新的场景。\n","slug":"Spring-Boot-和-Android-客户端-SSE-实现说明","date":"2024-12-09T07:58:01.000Z","categories_index":"Spring Boot,SSE,Android","tags_index":"Spring Boot,SSE,Android","author_index":"zhangyida"},{"id":"41881a9e23e37779fa5f8aab973b895f","title":"文件标签管理器","content":"\n    \n\nFILE-TAG-MANAGER-APP\n\n    ❯ REPLACE-ME\n\n\n    \n    \n    \n    \n\n\n\n\n    \n\n\n\n🔗 Table of Contents\n📍 Overview\n👾 Features\n📁 Project Structure\n📂 Project Index\n\n\n🚀 Getting Started\n☑️ Prerequisites\n⚙️ Installation\n🤖 Usage\n🧪 Testing\n\n\n📌 Project Roadmap\n🔰 Contributing\n🎗 License\n🙌 Acknowledgments\n\n\n📍 Overview❯ REPLACE-ME\n\n👾 Features❯ REPLACE-ME\n\n📁 Project Structure1234567891011121314└── file-tag-manager-app/    ├── README.md    ├── build.gradle.kts    ├── gradle    │   └── wrapper    │       ├── gradle-wrapper.jar    │       └── gradle-wrapper.properties    ├── gradle.properties    ├── gradlew    ├── gradlew.bat    ├── settings.gradle.kts    └── src        └── main            └── kotlin\n\n\n📂 Project Index\n    FILE-TAG-MANAGER-APP/\n     \n        __root__\n        \n            \n            \n                gradlew.bat\n                ❯ REPLACE-ME\n            \n            \n                build.gradle.kts\n                ❯ REPLACE-ME\n            \n            \n                settings.gradle.kts\n                ❯ REPLACE-ME\n            \n            \n        \n    \n     \n        src\n        \n            \n                main\n                \n                    \n                        kotlin\n                        \n                            \n                            \n                                Common.kt\n                                ❯ REPLACE-ME\n                            \n                            \n                                Db.kt\n                                ❯ REPLACE-ME\n                            \n                            \n                                TagManager.kt\n                                ❯ REPLACE-ME\n                            \n                            \n                                Context.kt\n                                ❯ REPLACE-ME\n                            \n                            \n                                FileTagMain.kt\n                                ❯ REPLACE-ME\n                            \n                            \n                        \n                    \n                \n            \n        \n    \n\n\n\n🚀 Getting Started☑️ PrerequisitesBefore getting started with file-tag-manager-app, ensure your runtime environment meets the following requirements:\n\nProgramming Language: Kotlin\nPackage Manager: Gradle\n\n⚙️ InstallationInstall file-tag-manager-app using one of the following methods:\nBuild from source:\n\nClone the file-tag-manager-app repository:\n1❯ git clone https://github.com/p-nickzhang-q/file-tag-manager-app\n\nNavigate to the project directory:\n1❯ cd file-tag-manager-app\n\nInstall the project dependencies:\n\n\nUsing gradle  \n1❯ gradle build\n\n\n\n\n🤖 UsageRun file-tag-manager-app using the following command:Using gradle  \n1❯ gradle run\n\n\n🧪 TestingRun the test suite using the following command:Using gradle  \n1❯ gradle test\n\n\n\n📌 Project Roadmap\n Task 1: Implement feature one.\n Task 2: Implement feature two.\n Task 3: Implement feature three.\n\n\n🔰 Contributing\n💬 Join the Discussions: Share your insights, provide feedback, or ask questions.\n🐛 Report Issues: Submit bugs found or log feature requests for the file-tag-manager-app project.\n💡 Submit Pull Requests: Review open PRs, and submit your own PRs.\n\n\nContributing Guidelines\n\n\nFork the Repository: Start by forking the project repository to your github account.\nClone Locally: Clone the forked repository to your local machine using a git client.1git clone https://github.com/p-nickzhang-q/file-tag-manager-app\nCreate a New Branch: Always work on a new branch, giving it a descriptive name.1git checkout -b new-feature-x\nMake Your Changes: Develop and test your changes locally.\nCommit Your Changes: Commit with a clear message describing your updates.1git commit -m &#x27;Implemented new feature x.&#x27;\nPush to github: Push the changes to your forked repository.1git push origin new-feature-x\nSubmit a Pull Request: Create a PR against the original project repository. Clearly describe the changes and their motivations.\nReview: Once your PR is reviewed and approved, it will be merged into the main branch. Congratulations on your contribution!\n\n\nContributor Graph\n\n\n   \n      \n   \n\n\n\n\n🎗 LicenseThis project is protected under the SELECT-A-LICENSE License. For more details, refer to the LICENSE file.\n\n🙌 Acknowledgments\nList any resources, contributors, inspiration, etc. here.\n\n\n","slug":"文件标签管理器","date":"2024-11-23T08:06:49.000Z","categories_index":"工具","tags_index":"工具","author_index":"zhangyida"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-11-22T07:22:03.147Z","categories_index":"","tags_index":"","author_index":"zhangyida"}]